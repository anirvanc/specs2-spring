<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
		"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="specifiction">
	<title>Spring Specification</title>

	<section id="specification-introduction">
		<title>Introduction to the Spring Specification</title>

		<para>This chapter covers the motivation, implementation and typical usage
			of the Spring Specification. The Spring Specification is an extension
			of the <ulink url="http://implicit.ly/specs2-10">Specs2</ulink> framework.
		</para>

		<para>The Specs2 Spring includes code that will help you set up the context for the
		entire integration test--and by context, we mean the appropriate entries in the
		JNDI environment as well as the beans under test, autowired in to the instance
		of the test under execution. Finally, Specs2 Spring can be easily configured
		to run every example in its own transaction that rolls back automatically when
		the example completes.</para>

		<para>The extension is meant to help you write tests in Scala to test your Spring code
			(whether implemented in Java or Scala). You will be able to take advantage of all
			the features of the Specs2 framework and apply them to the Spring test code.
		</para>

		<para>Specs2 Spring contains support for:</para>
		<itemizedlist>
			<listitem>
				<para>Multiple XA <code>DataSource</code>s to RDBMS as <code>javax.sql.DataSource</code>,</para>
			</listitem>
			<listitem>
				<para>Single XA transaction support as <code>javax.transaction.UserTransaction</code>,</para>
			</listitem>
			<listitem>
				<para>Multiple JMS queue and topic support <code>javax.jms.Queue</code>, <code>javax.jms.Topic</code>,
					<code>javax.jms.ConnectionFactory</code>,</para>
			</listitem>
			<listitem>
				<para>Multiple Javamail as <code>javax.mail.Session</code>,</para>
			</listitem>
			<listitem>
				<para>Multiple <code>WorkManager</code>s--both the <code>commonj.work.WorkManager</code> and
					the <code>javax.spi.resource.work.WorkManager</code>,</para>
			</listitem>
			<listitem>
				<para>Multiple arbitrary beans, as long as the types include accessible nullary constructor,</para>
			</listitem>
			<listitem>
				<para>Ability to register a class that can inject arbitrary entries into the JNDI environment.</para>
			</listitem>
		</itemizedlist>

		<section id="specification-testing">
			<title>Spring testing approaches</title>

			<para>In an integration test, you exercise code in multiple components working together.
				These components sometimes need
				<emphasis>external</emphasis>
				components, such as
				a<code>javax.sql.DataSource</code>,<code>javax.mail.Session</code>,
				<code>javax.jms.Queue</code>,<code>javax.jms.Topic</code>,
				<code>javax.transaction.TransactionManager</code>
				and
				many other components of the Java EE world.
			</para>

			<para>To keep the source code of our application as maintainable as possible and
				to remove as much complexity from the build process as possible, we should try to
				keep the source code that is running on the developers' machines
				<emphasis>exactly</emphasis>
				the same as the source code that is deployed on the pre-production servers as well
				as the production servers.
			</para>

			<para>The development machine may have its "own" RDBMS, specific configuration of the
				JMS infrastructure; the pre-production machine will have its specific configuration,
				and same will apply to the live machine. Moreover, some of the details of the configuration
				should be inaccessible to us. (For example, the connection details to the live RDBMS should
				be kept secret, not left to the developers to maintain.)
			</para>

			<para>Java offers a good way to achieve this: register the appropriate resources in
				JNDI. Taking a
				<emphasis>huge</emphasis>
				simplification, you may think of JNDI as
				<code>Map&lt;String, Object&gt;</code>
				(<code>Map[String, AnyRef]</code> in Scala speak).
				The application consumes objects from JNDI and uses them as the variable resources we explored
				in the previous few paragraphs.
			</para>

			<para>So, in addition to the test that makes up the test, we will need to include code
				that sets up JNDI for the test. The trouble is that such code would be repetitive
				if it were to be used more than once and we would need to ensure that it runs before
				any other code. Consider the following code snippet as an example.
			</para>

			<programlisting lang="java"><![CDATA[
class SomeTest extends Specification {
	// set-up JNDI environment

	"specification" in {
		success
	}
}
			]]></programlisting>
		</section>

		<section>
			<title>Spring Integration Testing</title>

			<para>The situation with JNDI is similar to the operations we need to set up the
			<interfacename>ApplicationContext</interfacename> that contains the beans under test. Once
			we have the <interfacename>ApplicationContext</interfacename>, we can inject the beans
			from that context into the test we are running. Expanding the code from the previous
			example, we can write:</para>

			<programlisting lang="java"><![CDATA[
class SomeTest extends Specification {
	// set-up JNDI environment
	ApplicationContext ac = new ClassPathXmlApplicationContext("...");
	val someService = ac.getBean(SomeService.class);

	"specification" in {
		success
	}
}
			]]></programlisting>

			<para>Additionally, we would like to examine whether the specifications hold
			(in the examples) in a way that isolates each example; when the example
			completes its work, we would like to roll back any changes we may have
			made to the system. In other words, it should be possible to run each example
			in its own transaction and that transaction should be automatically rolled back
			when the example finishes. We could write all this code by hand, but that would make
			the bodies of the examples far too noisy, it would distract us from the code
			that makes up the examples!</para>

			<para>The code in <classname>SomeTest</classname> now sets up everything we will
			need in the specifications. Specs2 Spring sets out to eliminate the duplication
			in setting up the <interfacename>ApplicationContext</interfacename> and the
			JNDI environment; and, if requested, executes each example in its own
			transaction and rolls back that transaction automatically when the example
			finishes.</para>
		</section>

	</section>

	<section>
		<title>Getting started</title>
		<para>You can delegate all this work to the code that makes up Specs2 Spring
		extension. Let's start with an example and then explore the details.</para>

		<programlisting lang="java"><![CDATA[
import org.springframework.beans.factory.annotation.Autowired
import org.specs2.spring.Specification
import org.springframework.test.context.ContextConfiguration
import org.specs2.spring.annotation.DataSource
import org.hsqldb.jdbc.JDBCDriver

@DataSource(name = "java:comp/env/jdbc/test",
  driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
class SomeTest extends Specification {
  @Autowired
  var someService: SomeService = _

  "specification" in {
    // call methods of someService that will hopefully return success!
    success
  }
}
		]]></programlisting>

		<para>The code in <classname>SomeTest</classname> includes <emphasis>variable</emphasis>
		of type <classname>SomeService</classname> that carries the <code>Autowired</code> annotation.
		This indicates to the Specs2 Spring extendsion that this field should be set to be the
		bean of type <classname>SomeService</classname> looked up from the <interfacename>ApplicationContext</interfacename>
		constructed by loading the configuration in <code>META-INF/spring/module-context.xml</code> files
		on the entire classpath. The code in one of the <code>META-INF/spring/module-context.xml</code>
		includes JNDI lookup of the <code>javax.sql.DataSource</code> under name
		<code>java:comp/env/jdbc/test</code>. </para>

		<programlisting lang="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/jee
		http://www.springframework.org/schema/jee/spring-jee.xsd">

	<context:component-scan base-package="org.specs2.springexample"/>
	<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/test"
		expected-type="javax.sql.DataSource"/>

</beans>
		]]></programlisting>

		<para>Notice the <code>jee:jndi-lookup</code> element, which queries the JNDI environment
		for the <code>java:comp/env/jdbc/test</code>, whose expected type is
		<interfacename>javax.sql.DataSource</interfacename>.</para>

		<para>To repeat the introductory parahgraph, the Specs2 Spring includes code that
		will help you set up the context for the entire integration test--and by context,
		we mean the appropriate entries in the JNDI environment as well as the beans under
		test, autowired in to the instance of the test under execution. Finally, Specs2
		Spring can be easily configured to run every example in its own transaction that
		rolls back automatically when the example completes.</para>
	</section>

	<section>
		<title>Using Specs2 Spring Extension</title>

		<para>To configure the Spring <interfacename>ApplicationContext</interfacename>, you
			need to use the <code>ContextConfiguration</code> annotation on a subclass of the
			<classname>org.specs2.spring.Specification</classname>. The code in the
			<classname>org.specs2.spring.Specification</classname> will build the
			<interfacename>ApplicationContext</interfacename> by instantiating the
			<classname>ClassPathXmlApplicationContext</classname> using the configuration
			files specified in the <code>values</code> property of the <code>ContextConfiguration</code>.
		</para>

		<para>Once the <classname>org.specs2.spring.Specification</classname> is done constructing
			the <interfacename>ApplicationContext</interfacename>, it will autowire the variables
			of the test using the beans in the context. (Obviously, you have to use the
			<code>Autowired</code> annotation on the variables that you want to have autowired.) Once
			the Spring <interfacename>ApplicationContext</interfacename> is ready and the variables
			autowired, you can use them in the bodies of the examples.</para>
			
		<para>In addition to setting up properly configured Spring <interfacename>ApplicationContext</interfacename>,
			Specs2 Spring sets up the JNDI environment for the test. This allows you to have the same Spring
			context configuration files, regardless of whether you are running tests, trying out the application
			on your own machine, deploying the application to pre-production servers or even running 
			your application live.</para>
			
		<para>In this section, you will find out how to configure your Spring <interfacename>ApplicationContext</interfacename>
			and how to configure the JNDI environment for your tests. Finally, we will discuss using running the
			examples in your specifications in their own transactions and controlling the behaviour of those
			transactions</para>
			
		<section>
			<title>Configuring the Spring ApplicationContext</title>
			
			<para>To create the Spring <interfacename>ApplicationContext</interfacename> for the test,
			it looks for the <interfacename>ContextConfiguration</interfacename> annotation on the test.
			<remark>Or the <interfacename>ContextConfiguration</interfacename> annotation on any annotation
			that the test is annotated with. See <xref linkend="annotated-annotation"/></remark>
			</para>

		</section>

		<section>
			<title>Understanding the Specs2 annotations</title>

			<para>The annotations on a Specs2 Spring test control &amp; define how the Spring <interfacename>ApplicationContext</interfacename>
			is constructed, define the elements of the JNDI environment required for the test and control the transactional
			behaviour of the examples. The annotations are:
			<table>
				<title>Specs2 Spring annotations</title>
				<tgroup cols="2">
					<colspec colwidth="6cm"/>
					<thead>
						<row>
							<entry>Annotation</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><code>ContextConfiguration</code></entry>
							<entry>Drives the way in which the Specs2 Spring extension will create the
							<classname>ClassPathXmlApplicationContext</classname></entry>
						</row>
						<row>
							<entry><code>Transactional</code></entry>
							<entry>Indicates that every example should run in its own transaction, the <code>TransactionConfiguration</code> annotation
							refines the transactional behaviour further</entry>
						</row>
						<row>
							<entry><code>TransactionConfiguration</code></entry>
							<entry>Tunes the transactional semantics that is applied to the transactional examples</entry>
						</row>
						<row>
							<entry><code>DataSource</code></entry>
							<entry>Adds the <code>javax.sql.DataSource</code> to the environment</entry>
						</row>
						<row>
							<entry><code>MailSession</code></entry>
							<entry>Adds the <code>javax.mail.Session</code> to the environment</entry>
						</row>
						<row>
							<entry><code>TransactionManager</code></entry>
							<entry>Adds the <code>javax.transaction.UserTransaction</code> to the environment</entry>
						</row>
						<row>
							<entry><code>Jms</code></entry>
							<entry>Adds the <code>javax.jms.ConnectionFactory</code> to the environment</entry>
						</row>
						<row>
							<entry><code>JmsTopic</code></entry>
							<entry>Adds the <code>javax.jms.Topic</code> to the environment</entry>
						</row>
						<row>
							<entry><code>JmsQueue</code></entry>
							<entry>Adds the <code>javax.jms.Queue</code> to the environment</entry>
						</row>
						<row>
							<entry><code>WorkManager</code></entry>
							<entry>Adds the <code>commonj.work.WorkManager</code> or <code>javax.spi.resource.work.WorkManager</code> to the environment</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			</para>

			<para>But there is one more annotation, <code>Jndi</code>, which aggregates all other annotations; moreover,
			it lets you specify <emphasis>multiple</emphasis> <code>DataSource</code>s, <code>Queue</code>s, <code>Topic</code>s, ....
			(Suppose you needed two <code>DataSource</code>s, you must use the <code>Jndi</code> annotation, you cannot annotate
			your specification with two <code>DataSource</code> annotations.) Its usage is straight-forward:
			<programlisting lang="java"><![CDATA[
@Jndi(
	dataSources = {
		@DataSource(name = "java:comp/env/jdbc/test",
			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:test"),
		@DataSource(name = "java:comp/env/jdbc/external",
			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:external")
	},
	mailSessions = @MailSession(name = "java:comp/env/mail/foo"),
	transactionManager =
		@TransactionManager(name = "java:comp/TransactionManager"),
	jms = @Jms(
		connectionFactoryName = "java:comp/env/jms/connectionFactory",
		queues = {
		  @JmsQueue(name = "java:comp/env/jms/requests"),
		  @JmsQueue(name = "java:comp/env/jms/responses")},
		topics = {
		  @JmsTopic(name = "java:comp/env/jms/cacheFlush"),
		  @JmsTopic(name = "java:comp/env/jms/ruleUpdate")}
	),
	workManagers = @WorkManager(name = "java:comp/env/work/WorkManager",
								kind = WorkManager.Kind.CommonJ)
)
@Transactional
@TransactionConfiguration(defaultRollback = true)
@ContextConfiguration("classpath*:/META-INF/spring/module-context.xml")
public class SomeTest ... {
}
			]]>
			</programlisting>
			</para>

			<para id="annotated-annotation">In Java, we can use (for example) the <code>DataSource</code> annotation as the element of the
			<code>dataSources</code> property of the <code>Jndi</code> annotation. Unfortunately,
			we have used the annotation on a Java class. You cannot use annotations as elements of the properties
			of an annotation in Scala. If you want to use the <code>Jndi</code> annotation in your Scala code, you have to
			create an annotation and <emphasis>annotate the custom annotation with the <code>Jndi</code> annotation</emphasis>.
			Typically, you will also include the <code>ContextConfiguration</code>, <code>Transactional</code> and
			<code>TransactionDefinition</code> on the custom annotation and use the custom annotation throughout
			your Specs2 code.
			<programlisting lang="java"><![CDATA[
@Jndi(
	dataSources = {
		@DataSource(name = "java:comp/env/jdbc/test",
			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:test"),
		@DataSource(name = "java:comp/env/jdbc/external",
			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:external")
	},
	mailSessions = @MailSession(name = "java:comp/env/mail/foo"),
	transactionManager =
		@TransactionManager(name = "java:comp/TransactionManager"),
	jms = @Jms(
		connectionFactoryName = "java:comp/env/jms/connectionFactory",
		queues = {
		  @JmsQueue(name = "java:comp/env/jms/requests"),
		  @JmsQueue(name = "java:comp/env/jms/responses")},
		topics = {
		  @JmsTopic(name = "java:comp/env/jms/cacheFlush"),
		  @JmsTopic(name = "java:comp/env/jms/ruleUpdate")}
	),
	workManagers = @WorkManager(name = "java:comp/env/work/WorkManager",
								kind = WorkManager.Kind.CommonJ)
)
@Transactional
@TransactionConfiguration(defaultRollback = true)
@ContextConfiguration("classpath*:/META-INF/spring/module-context.xml")
@Retention(RetentionPolicy.RUNTIME)
public @interface IntegrationTest {
}]]>
				</programlisting>
			You now have the <code>IntegrationTest</code> annotation (in Java), which you can use on your Scala
			specifications:
				<programlisting lang="scala"><![CDATA[
import org.specs2.spring.Specification
...

@IntegrationTest
class SomeComponentSpec extends Specification {
  ...
}]]>
				</programlisting>
			</para>

			<section>
				<title>The ContextConfiguration annotation</title>
				<para>The <code>ContextConfiguration</code> annotation is the core of the Specs2 Spring extension. This
				annotation configures how Specs2 Spring is going to construct the Spring <interfacename>ApplicationContext</interfacename>.
				Version 1.0 of Specs2 Scala examines only the <code>value</code> property; it ignores the <code>locations</code>,
				<code>inheritLocations</code> and <code>loader</code> properties that you may be used to in your
				Spring testing using the <code>spring-test</code> artifact.</para>

				<para>The <code>String[] value</code> property defines the array of locations the context files for the
				<classname>ClassPathXmlApplicationContext</classname> to use. For example, writing
				<code>@ContextConfiguration(Array("classpath*:/a.xml", "classpath*:/b.xml"))</code> will instruct
				the Specs2 Spring extension to create the Spring <interfacename>ApplicationContext</interfacename> by (in effect)
				calling <code>new ClassPathXmlApplicationContext(new String[]{"classpath*:/a.xml", "classpath*:/b.xml"})</code>.</para>

				<para>Once the <interfacename>ApplicationContext</interfacename> is constructed, the Specs2 Scala extension
				will inject the configured dependencies into the specification. Just like ordinary Java Spring code, you
				need to instruct the Specs2 Spring to perform the DI--in other words, use the <code>Autowired</code> annotation
				on fields (<code>var</code>s in Scala) or on the setters. <remark>For completeness, you may not use
				constructor injection.</remark>. A complete example of Specs2 Spring specification class that uses
				the <code>ContextConfiguration</code> annotation could be:
					<programlisting lang="scala"><![CDATA[
import org.specs2.spring.Specification
...

@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
class SomeComponentSpec extends Specification {
  @Autowired var someComponent: SomeComponent = _
  @Autowired var hibernateTemplate: HibernateTemplate = _

  "specification" in {
    ...
    success
  }
}]]>
					</programlisting>
				Notice in particular the <code>import org.specs2.spring.Specification</code>, application of the
				<code>@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))</code> and the
				two variables marked with the <code>Autowired</code> annotation. When you run the test, by the time
				the code of your examples (the <code>"specification" in { ... }</code>) runs, the variables will have
				been injected.
				</para>
			</section>

		</section>

	</section>

	<section id="best-practices">
		<title>Best Practices</title>

		<para>... One of the best practices for writing specifications that are split accross multiple
		classes is to aggregate all the annotations into a single annotation.</para>
	</section>

</chapter>
