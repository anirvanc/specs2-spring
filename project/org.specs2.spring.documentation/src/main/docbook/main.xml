<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
    <bookinfo>
        <title>Reference Documentation</title>
        <productname>Specs2 Spring</productname>
        <releaseinfo>1.0</releaseinfo>
        <!--
          <mediaobject>
              <imageobject role="fo">
                  <imagedata align="center" fileref="images/logo-pdf.png" format="PNG" width="240"/>
              </imageobject>
          </mediaobject>
          -->

        <authorgroup>
            <author>
                <firstname>Jan</firstname>
                <surname>Machacek</surname>
            </author>

            <author>
                <firstname>Anirvan</firstname>
                <surname>Chakraborty</surname>
            </author>

            <author>
                <firstname>Mark</firstname>
                <surname>Harrison</surname>
            </author>
        </authorgroup>

        <copyright>
            <year>2011</year>
            <holder>Jan Machacek, Anirvan Chakraborty, Mark Harrison</holder>
        </copyright>

        <legalnotice>
            <para>Copies of this document may be made for your own use and for
                distribution to others, provided that you do not charge any fee for such
                copies and further provided that each copy contains this Copyright
                Notice, whether distributed in print or electronically.
            </para>
        </legalnotice>
    </bookinfo>

    <!-- front matter -->

    <toc/>

     <part>
         <title>Overview of Specs2 Spring</title>
         <chapter id="introduction">
         	<title>Introducing Specs2 Spring</title>

         	<section>
         		<title>What is Specs2 Spring</title>
         		<para>This chapter covers the motivation, implementation and typical usage
         			of the Spring Specification. The Spring Specification is an extension
         			of the <ulink url="http://implicit.ly/specs2-10">Specs2</ulink> framework.
         		</para>

         		<para>The Specs2 Spring includes code that will help you set up the context for the
         		entire integration test--and by context, we mean the appropriate entries in the
         		JNDI environment as well as the beans under test, autowired in to the instance
         		of the test under execution. Finally, Specs2 Spring can be easily configured
         		to run every example in its own transaction that rolls back automatically when
         		the example completes.</para>

         		<para>The extension is meant to help you write tests in Scala to test your Spring code
         			(whether implemented in Java or Scala). You will be able to take advantage of all
         			the features of the Specs2 framework and apply them to the Spring test code.
         		</para>

         		<para><emphasis>Why bother</emphasis>, you ask? Because Specs2 and Scala allow you to be much more
         		expressive in your tests. Consequently, your tests can focus on the essence of what is being tested, reducing
         		the noise that the traditional Java code requires. A motivational example shows how to prepare test data,
         		insert them to the RDBMS and then verify that some service method works as expected.
         		<programlisting language="java"><![CDATA[
         import org.springframework.beans.factory.annotation.Autowired
         import org.springframework.orm.hibernate3.HibernateTemplate
         import org.specs2.spring.{BeanTables, HibernateDataAccess, Specification}

         @IntegrationTest
         class SomeComponentSpec extends Specification
           with HibernateDataAccess with BeanTables {
           @Autowired var someComponent: SomeComponent = _

           /**
            * Shows the usage of BeanTables and HibernateDataAccess to
            * set up and insert test objects using the convenient tabular notation.
            */
           "getByUsername finds existing Rider" in {
             "age" | "username" | "name" | "teamName" |
               32  ! "janm"     ! "Jan"  ! "Wheelers" |
               30  ! "anic"     ! "Ani"  ! "Team GB"  |> insert[Rider]

             this.someComponent.getByUsername("janm").getName must_== ("Jan")

           }
         }]]>
         		</programlisting>
         		There are several things at play here: the custom <code>IntegrationTest</code> annotation defines the environment for the
         		Spring components under test, the <code>Autowired</code> annotation on the <code>someComponent</code> variable
         		tells Specs2 Spring to inject the constructed bean. Finally, the example sets up some test data using <code>BeanTables</code>,
         		bulk-inserts them using the Hibernate ORM (method <code>insert[T]: (T => Result)</code> in <code>HibernateDataAccess</code>). Once
         		the set-up work is done, we proceed to verify the correct behaviour of the <code>getByUsername</code> method in <code>SomeComponent</code>.
         		Notably, the <code>"getByUsename finds existing Rider"</code> example runs in its own transaction. When the example
         		completes (whether successfully or unsuccessfully), the transaction is rolled back!
         		</para>
         		<para>The equivalent Java code would be <emphasis>much, much</emphasis> longer: you would be able to use the <code>spring-test</code>
         		artifact, giving you the ability to inject dependencies into your test and run the test methods in their own transactions.
         		Unfortunately, you would still be left to your own devices to set up the JNDI environment (which is non-trivial and
         		<emphasis>very</emphasis> repetitive work). Moreover, the body of the test method would contain much more noise,
         		distracting you from the test code.
         		</para>

         		<para>Specs2 Spring contains support to set-up:
         			<itemizedlist>
         				<listitem>
         					<para>Spring <interfacename>ApplicationContext</interfacename> from the specificed list of configuration files,</para>
         				</listitem>
         				<listitem>
         					<para>Multiple XA <code>DataSource</code>s to RDBMS as <code>javax.sql.DataSource</code>,</para>
         				</listitem>
         				<listitem>
         					<para>Single XA transaction support as <code>javax.transaction.UserTransaction</code>,</para>
         				</listitem>
         				<listitem>
         					<para>Multiple JMS queue and topic support <code>javax.jms.Queue</code>, <code>javax.jms.Topic</code>,
         						<code>javax.jms.ConnectionFactory</code>,</para>
         				</listitem>
         				<listitem>
         					<para>Multiple Javamail sessions as <code>javax.mail.Session</code>,</para>
         				</listitem>
         				<listitem>
         					<para>Multiple <code>WorkManager</code>s--both the <code>commonj.work.WorkManager</code> and
         						the <code>javax.spi.resource.work.WorkManager</code>,</para>
         				</listitem>
         				<listitem>
         					<para>Multiple arbitrary beans, as long as the types include accessible nullary constructor,</para>
         				</listitem>
         				<listitem>
         					<para>Ability to register a class that can inject arbitrary entries into the JNDI environment.</para>
         				</listitem>
         			</itemizedlist>
         			In addition to the set-up phase, Specs2 Spring extension enhances the behaviour of the examples by isolating
         			them (when required) in their own transactions.
         		</para>
         		<para>But there's much more to Specs2 Spring: on top of the set-up code, Specs2 Spring comes with convenience
         		traits that simplify setting up test data, manipulating data in ORM tools and relational databases.
         		</para>

         		<section id="specification-testing">
         			<title>Spring testing approaches</title>

         			<para>In an integration test, you exercise code in multiple components working together.
         				These components sometimes need
         				<emphasis>external</emphasis>
         				components, such as
         				a<code>javax.sql.DataSource</code>,<code>javax.mail.Session</code>,
         				<code>javax.jms.Queue</code>,<code>javax.jms.Topic</code>,
         				<code>javax.transaction.TransactionManager</code>
         				and
         				many other components of the Java EE world.
         			</para>

         			<para>To keep the source code of our application as maintainable as possible and
         				to remove as much complexity from the build process as possible, we should try to
         				keep the source code that is running on the developers' machines
         				<emphasis>exactly</emphasis>
         				the same as the source code that is deployed on the pre-production servers as well
         				as the production servers.
         			</para>

         			<para>The development machine may have its "own" RDBMS, specific configuration of the
         				JMS infrastructure; the pre-production machine will have its specific configuration,
         				and same will apply to the live machine. Moreover, some of the details of the configuration
         				should be inaccessible to us. (For example, the connection details to the live RDBMS should
         				be kept secret, not left to the developers to maintain.)
         			</para>

         			<para>Java offers a good way to achieve this: register the appropriate resources in
         				JNDI. Taking a
         				<emphasis>huge</emphasis>
         				simplification, you may think of JNDI as
         				<code>Map&lt;String, Object&gt;</code>
         				(<code>Map[String, AnyRef]</code> in Scala speak).
         				The application consumes objects from JNDI and uses them as the variable resources we explored
         				in the previous few paragraphs.
         			</para>

         			<para>So, in addition to the test that makes up the test, we will need to include code
         				that sets up JNDI for the test. The trouble is that such code would be repetitive
         				if it were to be used more than once and we would need to ensure that it runs before
         				any other code. Consider the following code snippet as an example.
         			</para>

         			<programlisting language="java"><![CDATA[
         class SomeTest extends Specification {

           "specification" in {
             // set-up JNDI environment
             // code that depends (consumes) the entries from JNDI
             success
           }

           "another specification" in {
             // set-up JNDI environment
             // code that depends (consumes) the entries from JNDI
             success
           }
         }
         			]]></programlisting>
         		</section>

         		<section>
         			<title>Spring Integration Testing</title>

         			<para>The situation with JNDI is similar to the operations we need to set up the
         			<interfacename>ApplicationContext</interfacename> that contains the beans under test. Once
         			we have the <interfacename>ApplicationContext</interfacename>, we can inject the beans
         			from that context into the test we are running. Expanding the code from the previous
         			example, we can write:</para>

         			<programlisting language="java"><![CDATA[
         class SomeTest extends Specification {
           // set-up JNDI environment

           "specification" in {
             // set-up JNDI environment
             // the Spring application that consumes the JNDI entries
             val someService = new ClassPathXmlApplicationContext("...").
               getBean(classOf[SomeService])
             success
           }

           "another specification" in {
             // set-up JNDI environment
             // the Spring application that consumes the JNDI entries
             val someService = new ClassPathXmlApplicationContext("...").
               getBean(classOf[SomeService])
             success
           }
         }]]>
         			</programlisting>

         			<para>Additionally, we would like to examine whether the specifications hold
         			(in the examples) in a way that isolates each example; when the example
         			completes its work, we would like to roll back any changes we may have
         			made to the system. In other words, it should be possible to run each example
         			in its own transaction and that transaction should be automatically rolled back
         			when the example finishes. We could write all this code by hand, but that would make
         			the bodies of the examples far too noisy, it would distract us from the code
         			that makes up the examples!</para>

         			<para>The code in <classname>SomeTest</classname> now sets up everything we will
         			need in the specifications. Specs2 Spring sets out to eliminate the duplication
         			in setting up the <interfacename>ApplicationContext</interfacename> and the
         			JNDI environment; and, if requested, executes each example in its own
         			transaction and rolls back that transaction automatically when the example
         			finishes.</para>
         		</section>

         	</section>

         	<section>
         		<title>Getting started</title>
         		<para>You can delegate all this work to the code that makes up Specs2 Spring
         		extension. Let's start with an example and then explore the details.</para>

         		<programlisting language="java"><![CDATA[
         import org.springframework.beans.factory.annotation.Autowired
         import org.specs2.spring.Specification
         import org.springframework.test.context.ContextConfiguration
         import org.specs2.spring.annotation.DataSource
         import org.hsqldb.jdbc.JDBCDriver

         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeTest extends Specification {
           @Autowired
           var someService: SomeService = _

           "specification" in {
             // call methods of someService that will hopefully return success!
             success
           }
         }
         		]]></programlisting>

         		<para>The code in <classname>SomeTest</classname> includes <emphasis>variable</emphasis>
         		of type <classname>SomeService</classname> that carries the <code>Autowired</code> annotation.
         		This indicates to the Specs2 Spring extendsion that this field should be set to be the
         		bean of type <classname>SomeService</classname> looked up from the <interfacename>ApplicationContext</interfacename>
         		constructed by loading the configuration in <code>META-INF/spring/module-context.xml</code> files
         		on the entire classpath. The code in one of the <code>META-INF/spring/module-context.xml</code>
         		includes JNDI lookup of the <code>javax.sql.DataSource</code> under name
         		<code>java:comp/env/jdbc/test</code>. </para>

         		<programlisting language="xml"><![CDATA[
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
         	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         	xmlns:context="http://www.springframework.org/schema/context"
         	xmlns:jee="http://www.springframework.org/schema/jee"
         	xsi:schemaLocation="http://www.springframework.org/schema/beans
         		http://www.springframework.org/schema/beans/spring-beans.xsd
         		http://www.springframework.org/schema/context
         		http://www.springframework.org/schema/context/spring-context.xsd
         		http://www.springframework.org/schema/jee
         		http://www.springframework.org/schema/jee/spring-jee.xsd">

         	<context:component-scan base-package="org.specs2.springexample"/>
         	<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/test"
         		expected-type="javax.sql.DataSource"/>

         </beans>
         		]]></programlisting>

         		<para>Notice the <code>jee:jndi-lookup</code> element, which queries the JNDI environment
         		for the <code>java:comp/env/jdbc/test</code>, whose expected type is
         		<interfacename>javax.sql.DataSource</interfacename>.</para>

         		<para>To repeat the introductory parahgraph, the Specs2 Spring includes code that
         		will help you set up the context for the entire integration test--and by context,
         		we mean the appropriate entries in the JNDI environment as well as the beans under
         		test, autowired in to the instance of the test under execution. Finally, Specs2
         		Spring can be easily configured to run every example in its own transaction that
         		rolls back automatically when the example completes.</para>
         	</section>

         </chapter>
     </part>

     <part>
         <title>Using Specs2 Spring</title>
         <chapter id="using">
         	<title>Using Specs2 Spring Specification</title>

         	<section>
         		<title>Using Specs2 Spring</title>
         		<para>To configure the Spring <interfacename>ApplicationContext</interfacename>, you
         			need to use the <code>ContextConfiguration</code> annotation on a subclass of the
         			<classname>org.specs2.spring.Specification</classname>. The code in the
         			<classname>org.specs2.spring.Specification</classname> will build the
         			<interfacename>ApplicationContext</interfacename> by instantiating the
         			<classname>ClassPathXmlApplicationContext</classname> using the configuration
         			files specified in the <code>values</code> property of the <code>ContextConfiguration</code>.
         		</para>

         		<para>Once the <classname>org.specs2.spring.Specification</classname> is done constructing
         			the <interfacename>ApplicationContext</interfacename>, it will autowire the variables
         			of the test using the beans in the context. (Obviously, you have to use the
         			<code>Autowired</code> annotation on the variables that you want to have autowired.) Once
         			the Spring <interfacename>ApplicationContext</interfacename> is ready and the variables
         			autowired, you can use them in the bodies of the examples.</para>

         		<para>In addition to setting up properly configured Spring <interfacename>ApplicationContext</interfacename>,
         			Specs2 Spring sets up the JNDI environment for the test. This allows you to have the same Spring
         			context configuration files, regardless of whether you are running tests, trying out the application
         			on your own machine, deploying the application to pre-production servers or even running
         			your application live.</para>

         		<para>In this section, you will find out how to configure your Spring <interfacename>ApplicationContext</interfacename>
         			and how to configure the JNDI environment for your tests. Finally, we will discuss using running the
         			examples in your specifications in their own transactions and controlling the behaviour of those
         			transactions</para>
         		<!--
         		<section>
         			<title>Configuring the Spring ApplicationContext</title>

         			<para>To create the Spring <interfacename>ApplicationContext</interfacename> for the test,
         			it looks for the <interfacename>ContextConfiguration</interfacename> annotation on the test.
         			<remark>Or the <interfacename>ContextConfiguration</interfacename> annotation on any annotation
         			that the test is annotated with. See <xref linkend="annotated-annotation"/></remark>
         			</para>

         		</section>
         		-->
         		<section>
         			<title>Understanding the Specs2 setup annotations</title>

         			<para id="setup-annotations">The annotations on a Specs2 Spring test control &amp; define how the Spring <interfacename>ApplicationContext</interfacename>
         			is constructed, define the elements of the JNDI environment required for the test. (See <xref linkend="behavioural-annotations"/>).
         			The set-up annotations are:
         			<table>
         				<title>Specs2 Spring annotations</title>
         				<tgroup cols="2">
         					<colspec colwidth="6cm"/>
         					<thead>
         						<row>
         							<entry>Annotation</entry>
         							<entry>Description</entry>
         						</row>
         					</thead>
         					<tbody>
         						<row>
         							<entry><code>ContextConfiguration</code></entry>
         							<entry>Drives the way in which the Specs2 Spring extension will create the
         							<classname>ClassPathXmlApplicationContext</classname></entry>
         						</row>
         						<row>
         							<entry><code>DataSource</code></entry>
         							<entry>Adds the <code>javax.sql.DataSource</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>TransactionManager</code></entry>
         							<entry>Adds the <code>javax.transaction.UserTransaction</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>Jms</code></entry>
         							<entry>Adds the <code>javax.jms.ConnectionFactory</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>JmsTopic</code></entry>
         							<entry>Adds the <code>javax.jms.Topic</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>JmsQueue</code></entry>
         							<entry>Adds the <code>javax.jms.Queue</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>MailSession</code></entry>
         							<entry>Adds the <code>javax.mail.Session</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>WorkManager</code></entry>
         							<entry>Adds the <code>commonj.work.WorkManager</code> or <code>javax.spi.resource.work.WorkManager</code> to the environment</entry>
         						</row>
         						<row>
         							<entry><code>Transactional</code></entry>
         							<entry>Indicates that every example should run in its own transaction, the <code>TransactionConfiguration</code> annotation
         							refines the transactional behaviour further</entry>
         						</row>
         						<row>
         							<entry><code>TransactionConfiguration</code></entry>
         							<entry>Tunes the transactional semantics that is applied to the transactional examples</entry>
         						</row>
         					</tbody>
         				</tgroup>
         			</table>
         			</para>

         			<para>But there is one more annotation, <code>Jndi</code>, which aggregates all other annotations; moreover,
         			it lets you specify <emphasis>multiple</emphasis> <code>DataSource</code>s, <code>Queue</code>s, <code>Topic</code>s, ....
         			(Suppose you needed two <code>DataSource</code>s, you must use the <code>Jndi</code> annotation, you cannot annotate
         			your specification with two <code>DataSource</code> annotations.) Its usage is straight-forward:
         			<programlisting language="java"><![CDATA[
         @Jndi(
         	dataSources = {
         		@DataSource(name = "java:comp/env/jdbc/test",
         			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:test"),
         		@DataSource(name = "java:comp/env/jdbc/external",
         			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:external")
         	},
         	mailSessions = @MailSession(name = "java:comp/env/mail/foo"),
         	transactionManager =
         		@TransactionManager(name = "java:comp/TransactionManager"),
         	jms = @Jms(
         		connectionFactoryName = "java:comp/env/jms/connectionFactory",
         		queues = {
         		  @JmsQueue(name = "java:comp/env/jms/requests"),
         		  @JmsQueue(name = "java:comp/env/jms/responses")},
         		topics = {
         		  @JmsTopic(name = "java:comp/env/jms/cacheFlush"),
         		  @JmsTopic(name = "java:comp/env/jms/ruleUpdate")}
         	),
         	workManagers = @WorkManager(name = "java:comp/env/work/WorkManager",
         								kind = WorkManager.Kind.CommonJ)
         )
         @Transactional
         @TransactionConfiguration(defaultRollback = true)
         @ContextConfiguration("classpath*:/META-INF/spring/module-context.xml")
         public class SomeTest ... {
         }
         			]]>
         			</programlisting>
         			</para>

         			<para id="annotated-annotation">In Java, we can use (for example) the <code>DataSource</code> annotation as the element of the
         			<code>dataSources</code> property of the <code>Jndi</code> annotation. Unfortunately,
         			we have used the annotation on a Java class. You cannot use annotations as elements of the properties
         			of an annotation in Scala. If you want to use the <code>Jndi</code> annotation in your Scala code, you have to
         			create an annotation and <emphasis>annotate the custom annotation with the <code>Jndi</code> annotation</emphasis>.
         			Typically, you will also include the <code>ContextConfiguration</code>, <code>Transactional</code> and
         			<code>TransactionDefinition</code> on the custom annotation and use the custom annotation throughout
         			your Specs2 code.
         			<programlisting language="java"><![CDATA[
         @Jndi(
         	dataSources = {
         		@DataSource(name = "java:comp/env/jdbc/test",
         			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:test"),
         		@DataSource(name = "java:comp/env/jdbc/external",
         			driverClass = JDBCDriver.class, url = "jdbc:hsqldb:mem:external")
         	},
         	mailSessions = @MailSession(name = "java:comp/env/mail/foo"),
         	transactionManager =
         		@TransactionManager(name = "java:comp/TransactionManager"),
         	jms = @Jms(
         		connectionFactoryName = "java:comp/env/jms/connectionFactory",
         		queues = {
         		  @JmsQueue(name = "java:comp/env/jms/requests"),
         		  @JmsQueue(name = "java:comp/env/jms/responses")},
         		topics = {
         		  @JmsTopic(name = "java:comp/env/jms/cacheFlush"),
         		  @JmsTopic(name = "java:comp/env/jms/ruleUpdate")}
         	),
         	workManagers = @WorkManager(name = "java:comp/env/work/WorkManager",
         								kind = WorkManager.Kind.CommonJ)
         )
         @Transactional
         @TransactionConfiguration(defaultRollback = true)
         @ContextConfiguration("classpath*:/META-INF/spring/module-context.xml")
         @Retention(RetentionPolicy.RUNTIME)
         public @interface IntegrationTest {
         }]]>
         				</programlisting>
         			You now have the <code>IntegrationTest</code> annotation (in Java), which you can use on your Scala
         			specifications:
         				<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         ...

         @IntegrationTest
         class SomeComponentSpec extends Specification {
           ...
         }]]>
         				</programlisting>
         			</para>

         			<section>
         				<title>The ContextConfiguration annotation</title>
         				<para>The <code>ContextConfiguration</code> annotation is the core of the Specs2 Spring extension. This
         				annotation configures how Specs2 Spring is going to construct the Spring <interfacename>ApplicationContext</interfacename>.
         				Version 1.0 of Specs2 Scala examines only the <code>value</code> property; it ignores the <code>locations</code>,
         				<code>inheritLocations</code> and <code>loader</code> properties that you may be used to in your
         				Spring testing using the <code>spring-test</code> artifact.</para>

         				<para>The <code>String[] value</code> property defines the array of locations the context files for the
         				<classname>ClassPathXmlApplicationContext</classname> to use. For example, writing
         				<code>@ContextConfiguration(Array("classpath*:/a.xml", "classpath*:/b.xml"))</code> will instruct
         				the Specs2 Spring extension to create the Spring <interfacename>ApplicationContext</interfacename> by (in effect)
         				calling <code>new ClassPathXmlApplicationContext(new String[]{"classpath*:/a.xml", "classpath*:/b.xml"})</code>.</para>

         				<para>Once the <interfacename>ApplicationContext</interfacename> is constructed, the Specs2 Scala extension
         				will inject the configured dependencies into the specification. Just like ordinary Java Spring code, you
         				need to instruct the Specs2 Spring to perform the DI--in other words, use the <code>Autowired</code> annotation
         				on fields (<code>var</code>s in Scala) or on the setters. <remark>For completeness, you may not use
         				constructor injection.</remark>. A complete example of Specs2 Spring specification class that uses
         				the <code>ContextConfiguration</code> annotation could be:
         					<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         ...

         @ContextConfiguration(
           Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeComponentSpec extends Specification {
           @Autowired var someComponent: SomeComponent = _
           @Autowired var hibernateTemplate: HibernateTemplate = _

           "specification" in {
             ...
             success
           }
         }]]>
         					</programlisting>
         				Notice in particular the <code>import org.specs2.spring.Specification</code>, application of the
         				<code>@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))</code> and the
         				two variables marked with the <code>Autowired</code> annotation. When you run the test, by the time
         				the code of your examples (the <code>"specification" in { ... }</code>) runs, the variables will have
         				been injected.
         				</para>
         			</section>

         			<section>
         				<title>The DataSource annotation</title>
         				<para>While the <code>ContextConfiguration</code> annotation drives the setup of the Spring
         				<interfacename>ApplicationContext</interfacename>, the JNDI annotations inject the appropriate
         				values to the environment for the test. The first JNDI annotation is <code>DataSource</code>.</para>

         				<para>The <code>DataSource</code> annotations adds the <interfacename>javax.sql.DataSource</interfacename>
         				object to JNDI; the properties of the annotations specify what JDBC driver to use, set the RDBMS connection
         				parameters and finally define the name for the <interfacename>javax.sql.DataSource</interfacename> in the
         				environment. If you include the <code>TransactionManager</code>, the <interfacename>DataSource</interfacename>
         				will be an XA (two-phase commit) one; otherwise, it will be the ordinary one.</para>

         				<para>The following code snippet shows typical configuration of the <code>DataSource</code> annotaiton:
         					<programlisting language="java"><![CDATA[
         @DataSource(
         	name = "java:comp/env/jdbc/test",
         	driverClass = JDBCDriver.class,
         	url = "jdbc:hsqldb:mem:test",
         	username = "sa",
         	password = "")]]>
         					</programlisting>
         				The code listing shows all properties of the <code>DataSource</code> annotation.
         				</para>
         				<table>
         					<title>Properties of the DataSource annotation</title>
         					<tgroup cols="2">
         						<colspec colwidth="4cm"/>
         						<thead>
         							<row>
         								<entry>Property</entry>
         								<entry>Description</entry>
         							</row>
         						</thead>
         						<tbody>
         							<row>
         								<entry><code>name</code></entry>
         								<entry>The name in JNDI environment that the created <interfacename>javax.sql.DataSource</interfacename>
         								should be registered under. This name must match the <code>jndi-name</code> of the <code>jee:jndi-lookup</code>
         								element of the Spring configuration file.</entry>
         							</row>
         							<row>
         								<entry><code>driverClass</code></entry>
         								<entry>The class of the JDBC driver (must be subtype of <interfacename>java.sql.Driver</interfacename></entry>
         							</row>
         							<row>
         								<entry><code>url</code></entry>
         								<entry>The JDBC connection URL; this string will vary according to the used JDBC driver.</entry>
         							</row>
         							<row>
         								<entry><code>username</code></entry>
         								<entry>The username to be used to create the connection to the RDBMS.</entry>
         							</row>
         							<row>
         								<entry><code>password</code></entry>
         								<entry>The password to be used to create the connection to the RDBMS.</entry>
         							</row>
         						</tbody>
         					</tgroup>
         				</table>
         				<para>The complete example that ties the <code>DataSource</code> annotation and the Spring
         				configuration file is simply:
         					<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         import org.hsqldb.jdbc.JDBCDriver
         ...

         @DataSource(
         	name = "java:comp/env/jdbc/test",
         	driverClass = classOf[JDBCDriver],
         	url = "jdbc:hsqldb:mem:test",
         	username = "sa",
         	password = "")
         @ContextConfiguration(
         	Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeSpecification extends Specification {
         	...
         }]]>
         					</programlisting>
         					The annotation on the specification class instructs the Specs2 Spring to add the <interfacename>javax.sql.DataSource</interfacename>
         					(that connects to HSQL DB using the <code>org.hsqldb.jdbc.JDBCDriver</code>, URL <code>jdbc:hsqldb:mem:test</code> and
         					credentials <code>sa/</code>) <emphasis>before</emphasis> constructing the Spring <interfacename>ApplicationContext</interfacename>
         					using the configuration files located at <code>/META-INF/spring/module-context.xml</code>. To consume
         					the registered JNDI entry in one of the context files, simply use the <code>jee:jndi-lookup</code> element.
         					<programlisting language="xml"><![CDATA[
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
         	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         	xmlns:context="http://www.springframework.org/schema/context"
         	xmlns:jee="http://www.springframework.org/schema/jee"
         	xsi:schemaLocation="http://www.springframework.org/schema/beans
         		http://www.springframework.org/schema/beans/spring-beans.xsd
         		http://www.springframework.org/schema/context
         		http://www.springframework.org/schema/context/spring-context.xsd
         		http://www.springframework.org/schema/jee
         		http://www.springframework.org/schema/jee/spring-jee.xsd">

         	<context:component-scan base-package="org.specs2.springexample"/>
         	<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/test"
         		expected-type="javax.sql.DataSource"/>

         </beans>]]>
         					</programlisting>
         					In the body of the specification, you can now request autowiring of the <code>dataSource</code> bean
         					(in addition to any beans that may be discovered by the <code>context:component-scan</code>).
         				</para>
         			</section>

         			<section>
         				<title>The TransactionManager annotation</title>
         				<para>It is typical to use some kind of transactional semantics in Spring applications. Spring Framework
         				abstracts out the details of how it is going to achieve this transactional behaviour by defining the
         				<interfacename>PlatformTransactionManager</interfacename> interface and providing several implementations
         				of the interface. There are, to name a few, <classname>DataSourceTransactionManager</classname>,
         				<classname>JpaTransactionManager</classname>, <classname>HibernateTransactionManager</classname> and many
         				other <emphasis>local</emphasis> transaction managers.</para>
         				<para>Imagine now that you would like the transaction to span across multiple transactional resources,
         				for example two RDBMSs, JMS queues and topics. In that scenario, these local transaction managers will not
         				work: being <emphasis>local</emphasis>, they can only manage the transactional semantics on a single
         				resource. The only transaction manager that can apply transactional semantics to <emphasis>multiple</emphasis>
         				resources is the <classname>JtaTransactionManager</classname>. As the name suggests, the
         				<classname>JtaTransactionManager</classname> is the implementation of the <interfacename>PlatformTransactionManager</interfacename>
         				that uses the Java transaction API-compliant manager. The manager is the implementation of the
         				<interfacename>javax.transaction.TransactionManager</interfacename> or <interfacename>javax.transaction.UserTransaction</interfacename>.
         				The Specs2 Spring includes support for the global transaction manager; if you use the
         				<code>TransactionManager</code> annotation, Specs2 Spring will also create all <code>DataSource</code>s
         				that are aware of the global transaction manager.
         				</para>
         				<para>The <code>TransactionManager</code> annotation includes only one property, <code>name</code>.
         					<table>
         						<title>Properties of the TransactionManager annotation</title>
         						<tgroup cols="2">
         							<colspec colwidth="4cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>name</code></entry>
         									<entry>The name in JNDI environment that the created <interfacename>javax.transaction.UserTransaction</interfacename>
         									should be registered under. Typically, the value of this property is <code>java:comp/TransactionManager</code></entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         				</para>
         				<para>Spring's <code>&lt;tx:jta-transaction-manager /&gt;</code> automatically scans the JNDI environment
         				for the JTA elements under <code>java:comp/TransactionManager</code> name. This makes typical usage
         				of this annotation very simple:
         					<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         import org.hsqldb.jdbc.JDBCDriver
         ...

         @DataSource(
         	name = "java:comp/env/jdbc/test",
         	driverClass = classOf[JDBCDriver],
         	url = "jdbc:hsqldb:mem:test",
         	username = "sa",
         	password = "")
         @TransactionManager(name = "java:comp/TransactionManager")
         @ContextConfiguration(
         	Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeSpecification extends Specification {
         	...
         }]]>
         					</programlisting>
         					The annotation on the specification class instructs the Specs2 Spring to add the <interfacename>javax.transaction.UserTransaction</interfacename>
         					to the environment. To consume the registered JNDI entry in one of the context files, simply use the
         					<code>tx:jta-transaction-manager</code> element.
         					<programlisting language="xml"><![CDATA[
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
         	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         	xmlns:context="http://www.springframework.org/schema/context"
         	xmlns:jee="http://www.springframework.org/schema/jee"
         	xsi:schemaLocation="http://www.springframework.org/schema/beans
         		http://www.springframework.org/schema/beans/spring-beans.xsd
         		http://www.springframework.org/schema/context
         		http://www.springframework.org/schema/context/spring-context.xsd
         		http://www.springframework.org/schema/jee
         		http://www.springframework.org/schema/jee/spring-jee.xsd">

         	<context:component-scan base-package="org.specs2.springexample"/>
         	<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/test"
         		expected-type="javax.sql.DataSource"/>
         	<tx:jta-transaction-manager />
         	<tx:annotation-driven />

         </beans>]]>
         					</programlisting>
         					In the body of the specification, you now have the <code>transactionManager</code> bean that has been
         					obtained by looking up the <code>java:comp/TransactionManager</code> name. Typically, you will
         					also need to include the <code>tx:annotation-driven</code> element to weave in the transactional
         					advices, allowing you to use the <code>Transactional</code> annotation on types and methods.
         					(And, ideally, you will use load- or compile-time weaving; tuning the <code>tx:annotation-driven</code>
         					element by specifying the mode attribute: <code>&lt;tx:annotation-driven mode="aspectj"/&gt;</code>.)
         				</para>
         			</section>
         			<section>
         				<title>JMS annotations</title>
         				<para>The JMS infrastructure combines multiple queues and topics under a connection factory. The
         				<interfacename>javax.jms.ConnectionFactory</interfacename> is the main "access point" to the
         				JMS infrastructure. Spring applications make use of the connection factory to register code
         				to be called whenever a message appears on a queue; the code of JMS-based Spring applications
         				typically also needs to have access to the queues and topics.</para>
         				<para>The <interfacename>javax.jms.ConnectionFactory</interfacename>, <interfacename>javax.jms.Queue</interfacename>
         				and <interfacename>javax.jms.Topic</interfacename> objects are usually looked up from JNDI.</para>
         				<para>The basic setup of the JMS infrastructure therefore requires that you use the <code>Jms</code> annotation,
         				specifying the name for the connection factory and either a <code>JmsTopic</code> and/or <code>JmsQueue</code> that
         				define the JMS topic and queue, respectively. All three annotations only require you to set the the name in the
         				environment (and which must match the <code>jndi-name</code> attribute of the <code>jee:jndi-lookup</code> element).</para>
         				<para>The following code snippet shows typical configuration of the JMS annotaitons:
         					<programlisting language="java"><![CDATA[
         @Jms(connectionFactoryName = "java:comp/env/jms/connectionFactory")
         @JmsQueue(name = "java:comp/env/jms/requests")
         @JmsTopic(name = "java:comp/env/jms/cacheFlush")
         class SomeSpecification extends Specification {
           ...
         }]]>
         					</programlisting>
         				Exploring the properties of each annotation further, we have:
         					<table>
         						<title>Properties of the JMS annotation</title>
         						<tgroup cols="2">
         							<colspec colwidth="6cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>connectionFactoryName</code></entry>
         									<entry>The name in JNDI environment that the created <interfacename>javax.jms.ConnectionFactory</interfacename>
         									should be registered under.</entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         					<table>
         						<title>Properties of the JMS queue</title>
         						<tgroup cols="2">
         							<colspec colwidth="4cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>name</code></entry>
         									<entry>The name in JNDI environment that the created <interfacename>javax.jms.Queue</interfacename>
         									should be registered under.</entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         					<table>
         						<title>Properties of the JmsTopic annotation</title>
         						<tgroup cols="2">
         							<colspec colwidth="4cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>name</code></entry>
         									<entry>The name in JNDI environment that the created <interfacename>javax.jms.Topic</interfacename>
         									should be registered under.</entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         				</para>
         				<para>Expanding the previous examples with the JMS annotations, we now have:
         					<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         import org.hsqldb.jdbc.JDBCDriver
         ...

         @DataSource(
         	name = "java:comp/env/jdbc/test",
         	driverClass = classOf[JDBCDriver],
         	url = "jdbc:hsqldb:mem:test",
         	username = "sa",
         	password = "")
         @Jms(connectionFactoryName = "java:comp/env/jms/connectionFactory")
         @JmsQueue(name = "java:comp/env/jms/requests")
         @JmsTopic(name = "java:comp/env/jms/cacheFlush")
         @ContextConfiguration(
         	Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeSpecification extends Specification {
         	...
         }]]>
         				</programlisting>
         				In addition to the RDBMS and the global transaction manager, we define a JMS infrastructure and one
         				queue and one topic. We consume the newly defined elements in the Spring configuration file
         				using the <code>jee:jndi-lookup</code> element.
         					<programlisting language="xml"><![CDATA[
         <?xml version="1.0" encoding="UTF-8"?>
         <beans xmlns="http://www.springframework.org/schema/beans"
         	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         	xmlns:context="http://www.springframework.org/schema/context"
         	xmlns:jee="http://www.springframework.org/schema/jee"
         	xsi:schemaLocation="http://www.springframework.org/schema/beans
         		http://www.springframework.org/schema/beans/spring-beans.xsd
         		http://www.springframework.org/schema/context
         		http://www.springframework.org/schema/context/spring-context.xsd
         		http://www.springframework.org/schema/jee
         		http://www.springframework.org/schema/jee/spring-jee.xsd">

         	<context:component-scan base-package="org.specs2.springexample"/>
         	<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/test"
         		expected-type="javax.sql.DataSource"/>
         	<tx:jta-transaction-manager />
         	<tx:annotation-driven />
         	<jee:jndi-lookup id="connectionFactory"
         		jndi-name="java:comp/env/jms/connectionFactory"
         		expected-type="javax.jms.ConnectionFactory"/>
         	<jee:jndi-lookup id="requests"
         		jndi-name="java:comp/env/jms/requests"
         		expected-type="javax.jms.Queue"/>
         	<jee:jndi-lookup id="cacheFlush"
         		jndi-name="java:comp/env/jms/cacheFlush"
         		expected-type="javax.jms.Topic"/>

         </beans>]]>
         					</programlisting>
         					Note that in the sample code, the global transaction manager (registered using the
         					<code>TransactionManager</code> annotation) can manage transactions over all transactional resources;
         					in this case, the RDBMS <emphasis>and</emphasis> the JMS queue or topic.
         				</para>
         				<para>Most applications require more than one queue or topic; some applications even require
         				more than one connection factory. In that situation, you must use the <emphasis>annotated annotation</emphasis>
         				approach we already demonstrated (see <xref linkend="annotated-annotation"/> or **advanced-xref**).</para>
         			</section>
         			<section>
         				<title>The MailSession annotation</title>
         				<para>If you are sending e-mails from your application, you will need the <classname>javax.mail.Session</classname>, which
         					allows you to construct <classname>javax.mail.Message</classname> (including the complex multipart messages,
         					deal with attachments and many other e-mail tasks). Just like all other JNDI annotations, you need to
         					specify the name for the entry in JNDI and configure the remaining properties of the Javamail session.
         				</para>
         				<para>The following code snippet shows typical configuration of the <code>MailSession</code> annotaiton:
         					<programlisting language="java"><![CDATA[
         @MailSession(
         	name = "java:comp/env/mail/foo",
         	properties = Array("mail.smtp.host=localhost", "mail.mime.charset=UTF-8"))
         ]]>
         					</programlisting>
         					Exploring the properties of the annotation further, we have:
         					<table>
         						<title>Properties of the MailSession annotation</title>
         						<tgroup cols="2">
         							<colspec colwidth="4cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>name</code></entry>
         									<entry>The name in JNDI environment that the created <classname>javax.mail.Session</classname>
         									should be registered under.</entry>
         								</row>
         								<row>
         									<entry><code>properties</code></entry>
         									<entry>The array of <code>String</code>s that represent the Javamail properties, in form of
         									<emphasis>property-key</emphasis>=<emphasis>property-value</emphasis>. For example, if you wish
         									to specify the <code>mail.smtp.host</code> to <code>localhost</code> and <code>mail.mime.charset</code>
         									to <code>UTF-8</code>, you write <code>properties = Array("mail.smtp.host=localhost", "mail.mime.charset=UTF-8")</code></entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         				</para>
         				<para>To consume the <classname>javax.mail.Session</classname> in your Spring application, use the
         				familiar <code>jee:jndi-lookup</code> element and make sure that the value of the <code>jndi-name</code>
         				attribute matches the value of the <code>name</code> property of the <code>MailSession</code> annotation.</para>
         			</section>
         			<section>
         				<title>The WorkManager annotation</title>
         				<para>Finally, some applications use one of the two common <interfacename>WorkManager</interfacename> implementations
         					to submit work to [a pool of] threads. Typically, the application server maintains and monitors the <interfacename>WorkManager</interfacename>
         					instance. The application servers allow the administrators to configure the threads that should become
         					parts of the <interfacename>WorkManager</interfacename> instances. Finally, the application servers usually
         					then report on the load of the <interfacename>WorkManager</interfacename>. All that is left to us is
         					to consume the <interfacename>WorkManager</interfacename> and use it in our application.
         					<remark>Having the application server maintain the <interfacename>WorkManager</interfacename> instances
         					is far better approach than creating your own thread pools within your application.</remark>
         				</para>
         				<para>To configure the <interfacename>WorkManager</interfacename>, all you need to specify is the JNDI name and
         					set the remaining properties:
         					<programlisting language="java"><![CDATA[
         @WorkManager(name = "java:comp/env/work/WorkManager",
         	kind = WorkManager.Kind.CommonJ,
         	maximumThreads = 5,
         	minimumThreads = 3)
         ]]>
         					</programlisting>
         					Exploring the properties of the annotation further, we have:
         					<table>
         						<title>Properties of the WorkManager annotation</title>
         						<tgroup cols="2">
         							<colspec colwidth="4cm"/>
         							<thead>
         								<row>
         									<entry>Property</entry>
         									<entry>Description</entry>
         								</row>
         							</thead>
         							<tbody>
         								<row>
         									<entry><code>name</code></entry>
         									<entry>The name in JNDI environment that the created <classname>javax.mail.Session</classname>
         									should be registered under.</entry>
         								</row>
         								<row>
         									<entry><code>kind</code></entry>
         									<entry>Defines the kind of the created <interfacename>WorkManager</interfacename> instance.
         										If the value is <code>WorkManager.Kind.CommonJ</code>, then the instance will implement the
         										the <interfacename>commonj.work.WorkManager</interfacename>.
         										If the value is <code>WorkManager.Kind.Javax</code>, then the instance will implement the
         										<interfacename>javax.spi.resource.work.WorkManager</interfacename>.</entry>
         								</row>
         								<row>
         									<entry><code>maximumThreads</code></entry>
         									<entry>The maximum number of threads the created work manager should allow to be created.
         									Must be greater than 1 and greater than <code>minimumThreads</code>.</entry>
         								</row>
         								<row>
         									<entry><code>minimumThreads</code></entry>
         									<entry>The minimum number of threads the created work manager should create.
         									Must be greater than 0 and smaller than <code>minimumThreads</code>.</entry>
         								</row>
         							</tbody>
         						</tgroup>
         					</table>
         				</para>
         				<para>To consume the work manager in your Spring application, use the familiar <code>jee:jndi-lookup</code>
         				element and make sure that the value of the <code>jndi-name</code> attribute matches the value of the
         				<code>name</code> property of the <code>WorkManager</code> annotation.</para>
         			</section>
         		</section>
         		<section>
         			<title>Understanding the Specs2 behavioural annotations</title>

         			<para id="behavioural-annotations">The annotations on a Specs2 Spring behavioural annotations control the runtime of the examples. The behaviour
         				defines the transactional semantics that will be applied to the examples. The transactional example
         				behavioural support needs to have access to the <interfacename>PlatformTransactionManager</interfacename> bean.
         				This <interfacename>PlatformTransactionManager</interfacename> can be any of its implementations,
         				even the local one, if it is appropriate for your code. Typically, though, you will use the <code>TransactionManager</code>
         				annotation together with the <code>tx:jta-transaction-manager</code> element, which exposes the
         				transaction manager that the Specs2 Spring will use to apply the transactional behaviour to the examples.
         				(See <xref linkend="setup-annotations"/>).
         			<table>
         				<title>Specs2 Spring behavioural annotations</title>
         				<tgroup cols="2">
         					<colspec colwidth="6cm"/>
         					<thead>
         						<row>
         							<entry>Annotation</entry>
         							<entry>Description</entry>
         						</row>
         					</thead>
         					<tbody>
         						<row>
         							<entry><code>Transactional</code></entry>
         							<entry>Indicates that every example should run in its own transaction, the <code>TransactionConfiguration</code> annotation
         							refines the transactional behaviour further</entry>
         						</row>
         						<row>
         							<entry><code>TransactionConfiguration</code></entry>
         							<entry>Tunes the transactional semantics that is applied to the transactional examples</entry>
         						</row>
         					</tbody>
         				</tgroup>
         			</table>
         			When you annotate your test class with the <code>Transactional</code> annotation, every example will run
         			in its own transaction and the transaction will be rolled back automatically when the example finishes. You
         			can tune whether the transaction rolls back or commits by using the <code>defaultRollback</code> property
         			of the <code>TransactionConfiguration</code> annotation. If <code>defaultRollback</code> is <code>false</code>,
         			the transaction will <emphasis>commit</emphasis> when the example finishes; if the value is <code>false</code>
         			(the default), the transaction will roll back.
         			</para>
         		</section>
         	</section>

         </chapter>
         <chapter id="large-systems">
         	<title>Testing large systems using Specs2 Spring</title>

         	<section>
         		<title>What are large systems?</title>
         		<para>Before we explore the intricacies of the code involved in testing large systems, we need to explore
         			what we mean by <emphasis>large system</emphasis>. In what we call large systems, there are many components
         			that need to be tested and those components depend on many other Java EE components. Moreover, the structure
         			of the code should be as <emphasis>elegant</emphasis> and <emphasis>flexible</emphasis> as possible, without
         			imposing technical restrictions.
         		</para>
         		<para>Let's take a quick detour to explore the structure of large Spring applications. Enterprise [Spring] applications
         		are usually made up of modules; in the smallest applications, these modules represent the tiers. The application
         		is then simple packaging of these modules. Let's start with a small application that consists of four such modules.
         		We have the <code>domain</code>, <code>repository</code>, <code>services</code> and the <code>webapp</code>.
         		</para>
         		<para>The most efficient configuration structure is to create <emphasis>self-configuring modules</emphasis>. This
         		means that every module that contains Spring functionality should carry just enough configuration to configure
         		itself. Consequently, if we want to add functionality to the application, all that it take is to add the module
         		to the application; no other portion of our application needs to change. Consider structure of application called
         		<code>org.specs2.app</code>:
         		<programlisting language="shell"><![CDATA[
         org.specs2.app.domain
         src
         main
           java
         	org.specs2.app.domain
           scala
         	org.specs2.app.domain
         test
           java
         	org.specs2.app.domain
           scala
         	org.specs2.app.domain
         org.specs2.app.repository
         src
         main
           resources
         	META-INF
         	  spring
         		module-context.xml
         org.specs2.app.services
         src
         main
           resources
         	META-INF
         	  spring
         		module-context.xml
           scala
         	org.specs2.app.services
         	  SomeService.scala
         test
           scala
         	org.specs2.app.services
         	  SomeServiceSpecification.scala
         org.specs2.app.webapp
         src
         main
         test
         webapp]]>
         		</programlisting>
         			This rather long listing of directories shows that every module contains the <code>/META-INF/spring/module-context.xml</code>
         			file. This file contains the Spring elements that are defined in the module.
         		</para>
         		<para>Consider this example: in the <code>repository</code>, the <code>module-context.xml</code> defines,
         			for example, the <code>HibernateTemplate</code> bean. The <code>services</code> <emphasis>depends on</emphasis>
         			the <code>repository</code> module, therefore all beans defined in the <code>repository</code>
         			module are "visible" in the <code>module-context.xml</code> file in the <code>services</code> module.
         			The <code>webapp</code> then assembles two Spring application contexts: one for the user interface portion
         			of the application and another application context that contains the headless beans.
         		</para>
         		<mediaobject>
         			<imageobject role="fo">
         				<imagedata align="left" valign="top" fileref="images/layers.png" format="PNG" scale="0.7"/>
         			</imageobject>
         		</mediaobject>
         		<para>Notice in particular the naming convention; particularly the <code>module-context.xml</code> files. If all
         		other modules in your application follow the <emphasis>self-configured</emphasis> route, then adding new
         		functionality to the application is as easy as adding a dependency.</para>
         	</section>
         	<section>
         		<title>Testing large systems</title>
         		<para>To test these large systems, we need to set up the environment for the test. The configuration that brings
         		together the individual configuration files from the different modules is easy. If you had followed our naming
         		advice, all you have to do is to annotate your tests with
         		<code>@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))</code>. This will load
         		the configuration from <emphasis>all <code>module-context.xml</code>-named files in all modules on the classpath</emphasis>!
         		</para>
         		<para>In addition to setting up the Spring <interfacename>ApplicationContext</interfacename>, we need to set up
         		other Java EE components that the beans depend on. Such components include, for example, a JNDI-bound
         		<interfacename>javax.sql.DataSource</interfacename>, <classname>javax.mail.Session</classname>,
         		<interfacename>javax.transaction.UserTransaction</interfacename>, and many others. Furthermore, we need to set up
         		the transactional behaviour of the tests itself.
         		</para>
         		<para>The annotations you need to define all these components are the common Specs2 Spring annotations
         		(viz <xref linkend="setup-annotations" />). Repeating the Specs2 annotations on every test results in clear
         		code duplication. To reduce the code duplication, you should create custom Java annotation and annotate that annotation
         		with the required Specs2 annotations; and use your custom annotation on your tests. Instead of having multiple
         		tests that duplicate the same annotations:
         			<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         ...

         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeServiceTest extends Specification {
           @Autowired
           var someService: SomeService = _

           "specification" in {
             // call methods of someService that will hopefully return success!
             success
           }
         }

         import org.specs2.spring.Specification
         ...

         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         class AnotherServiceTest extends Specification {
           @Autowired
           var anotherService: AnotherService = _

           "specification" in {
             // call methods of anotherService that will hopefully return success!
             success
           }
         }]]></programlisting>
         		We will create a custom annotation, and annotate it with the Specs2 annotations and use it on our tests:
         			<programlisting language="java"><![CDATA[
         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         @Retention(RetentionPolicy.RUNTIME)
         public @interface IntegrationTest {
         }


         import org.specs2.spring.Specification
         ...

         @IntegrationTest
         class SomeServiceTest extends Specification {
           @Autowired
           var someService: SomeService = _

           "specification" in {
             // call methods of someService that will hopefully return success!
             success
           }
         }

         import org.specs2.spring.Specification
         ...

         @IntegrationTest
         class AnotherServiceTest extends Specification {
           @Autowired
           var anotherService: AnotherService = _

           "specification" in {
             // call methods of anotherService that will hopefully return success!
             success
           }
         }]]></programlisting>
         		</para>
         		<section>
         			<title>Multiple environment entries</title>
         			<para>In the previous example, we have used a single <interfacename>javax.sql.DataSource</interfacename>,
         			<interfacename>javax.mail.Session</interfacename> (and many others). However, some applications
         			require <emphasis>many</emphasis> of those Java EE components. Unfortunately, it is not possible
         			to duplicate annotations on a class. We can't, for example, use two <code>DataSource</code> annotations.</para>
         			<para>Instead, we must use the <code>Jndi</code> annotation and specify the <code>DataSource</code>s in
         			its <code>dataSource</code> property. <remark>Even more unfortunately, we cannot use the <code>Jndi</code>
         			annotation in our Scala code, we must use the custom Java annotation route.</remark></para>

         			<para>The JNDI annotation defines the following properties, which let you define multiple Java EE
         			components of the required type.

         			</para>
         		</section>
         	</section>

         </chapter>
     </part>

     <part id="spring-appendices">
       <title>What's next?</title>

         <chapter id="whats-next">
         	<title>Testing large systems using Specs2 Spring</title>

         	<section>
         		<title>What are large systems?</title>
         		<para>Before we explore the intricacies of the code involved in testing large systems, we need to explore
         			what we mean by <emphasis>large system</emphasis>. In what we call large systems, there are many components
         			that need to be tested and those components depend on many other Java EE components. Moreover, the structure
         			of the code should be as <emphasis>elegant</emphasis> and <emphasis>flexible</emphasis> as possible, without
         			imposing technical restrictions.
         		</para>
         		<para>Let's take a quick detour to explore the structure of large Spring applications. Enterprise [Spring] applications
         		are usually made up of modules; in the smallest applications, these modules represent the tiers. The application
         		is then simple packaging of these modules. Let's start with a small application that consists of four such modules.
         		We have the <code>domain</code>, <code>repository</code>, <code>services</code> and the <code>webapp</code>.
         		</para>
         		<para>The most efficient configuration structure is to create <emphasis>self-configuring modules</emphasis>. This
         		means that every module that contains Spring functionality should carry just enough configuration to configure
         		itself. Consequently, if we want to add functionality to the application, all that it take is to add the module
         		to the application; no other portion of our application needs to change. Consider structure of application called
         		<code>org.specs2.app</code>:
         		<programlisting language="shell"><![CDATA[
         org.specs2.app.domain
         src
         main
           java
         	org.specs2.app.domain
           scala
         	org.specs2.app.domain
         test
           java
         	org.specs2.app.domain
           scala
         	org.specs2.app.domain
         org.specs2.app.repository
         src
         main
           resources
         	META-INF
         	  spring
         		module-context.xml
         org.specs2.app.services
         src
         main
           resources
         	META-INF
         	  spring
         		module-context.xml
           scala
         	org.specs2.app.services
         	  SomeService.scala
         test
           scala
         	org.specs2.app.services
         	  SomeServiceSpecification.scala
         org.specs2.app.webapp
         src
         main
         test
         webapp]]>
         		</programlisting>
         			This rather long listing of directories shows that every module contains the <code>/META-INF/spring/module-context.xml</code>
         			file. This file contains the Spring elements that are defined in the module.
         		</para>
         		<para>Consider this example: in the <code>repository</code>, the <code>module-context.xml</code> defines,
         			for example, the <code>HibernateTemplate</code> bean. The <code>services</code> <emphasis>depends on</emphasis>
         			the <code>repository</code> module, therefore all beans defined in the <code>repository</code>
         			module are "visible" in the <code>module-context.xml</code> file in the <code>services</code> module.
         			The <code>webapp</code> then assembles two Spring application contexts: one for the user interface portion
         			of the application and another application context that contains the headless beans.
         		</para>
         		<mediaobject>
         			<imageobject role="fo">
         				<imagedata align="left" valign="top" fileref="images/layers.png" format="PNG" scale="0.7"/>
         			</imageobject>
         		</mediaobject>
         		<para>Notice in particular the naming convention; particularly the <code>module-context.xml</code> files. If all
         		other modules in your application follow the <emphasis>self-configured</emphasis> route, then adding new
         		functionality to the application is as easy as adding a dependency.</para>
         	</section>
         	<section>
         		<title>Testing large systems</title>
         		<para>To test these large systems, we need to set up the environment for the test. The configuration that brings
         		together the individual configuration files from the different modules is easy. If you had followed our naming
         		advice, all you have to do is to annotate your tests with
         		<code>@ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))</code>. This will load
         		the configuration from <emphasis>all <code>module-context.xml</code>-named files in all modules on the classpath</emphasis>!
         		</para>
         		<para>In addition to setting up the Spring <interfacename>ApplicationContext</interfacename>, we need to set up
         		other Java EE components that the beans depend on. Such components include, for example, a JNDI-bound
         		<interfacename>javax.sql.DataSource</interfacename>, <classname>javax.mail.Session</classname>,
         		<interfacename>javax.transaction.UserTransaction</interfacename>, and many others. Furthermore, we need to set up
         		the transactional behaviour of the tests itself.
         		</para>
         		<para>The annotations you need to define all these components are the common Specs2 Spring annotations
         		(viz <xref linkend="setup-annotations" />). Repeating the Specs2 annotations on every test results in clear
         		code duplication. To reduce the code duplication, you should create custom Java annotation and annotate that annotation
         		with the required Specs2 annotations; and use your custom annotation on your tests. Instead of having multiple
         		tests that duplicate the same annotations:
         			<programlisting language="java"><![CDATA[
         import org.specs2.spring.Specification
         ...

         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         class SomeServiceTest extends Specification {
           @Autowired
           var someService: SomeService = _

           "specification" in {
             // call methods of someService that will hopefully return success!
             success
           }
         }

         import org.specs2.spring.Specification
         ...

         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         class AnotherServiceTest extends Specification {
           @Autowired
           var anotherService: AnotherService = _

           "specification" in {
             // call methods of anotherService that will hopefully return success!
             success
           }
         }]]></programlisting>
         		We will create a custom annotation, and annotate it with the Specs2 annotations and use it on our tests:
         			<programlisting language="java"><![CDATA[
         @DataSource(name = "java:comp/env/jdbc/test",
           driverClass = classOf[JDBCDriver], url = "jdbc:hsqldb:mem:test")
         @Transactional
         @ContextConfiguration(Array("classpath*:/META-INF/spring/module-context.xml"))
         @Retention(RetentionPolicy.RUNTIME)
         public @interface IntegrationTest {
         }


         import org.specs2.spring.Specification
         ...

         @IntegrationTest
         class SomeServiceTest extends Specification {
           @Autowired
           var someService: SomeService = _

           "specification" in {
             // call methods of someService that will hopefully return success!
             success
           }
         }

         import org.specs2.spring.Specification
         ...

         @IntegrationTest
         class AnotherServiceTest extends Specification {
           @Autowired
           var anotherService: AnotherService = _

           "specification" in {
             // call methods of anotherService that will hopefully return success!
             success
           }
         }]]></programlisting>
         		</para>
         		<section>
         			<title>Multiple environment entries</title>
         			<para>In the previous example, we have used a single <interfacename>javax.sql.DataSource</interfacename>,
         			<interfacename>javax.mail.Session</interfacename> (and many others). However, some applications
         			require <emphasis>many</emphasis> of those Java EE components. Unfortunately, it is not possible
         			to duplicate annotations on a class. We can't, for example, use two <code>DataSource</code> annotations.</para>
         			<para>Instead, we must use the <code>Jndi</code> annotation and specify the <code>DataSource</code>s in
         			its <code>dataSource</code> property. <remark>Even more unfortunately, we cannot use the <code>Jndi</code>
         			annotation in our Scala code, we must use the custom Java annotation route.</remark></para>

         			<para>The JNDI annotation defines the following properties, which let you define multiple Java EE
         			components of the required type.

         			</para>
         		</section>
         	</section>

         </chapter>
     </part>

</book>